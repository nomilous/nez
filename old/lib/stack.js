// Generated by CoffeeScript 1.4.0
var Emitter, Hooks, Link, Node, Plugins, Stack, injector,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

require('fing');

Node = require('./node');

injector = require('nezcore').injector;

Hooks = require('./hooks');

Link = require('./link');

Plugins = require('./plugin_register');

Emitter = require('events').EventEmitter;

module.exports = Stack = (function(_super) {

  __extends(Stack, _super);

  function Stack(activeNode) {
    this.activeNode = activeNode;
    this.stacker = __bind(this.stacker, this);

    this.label = this.activeNode.label;
    this.stack = [];
    this.classes = [];
    this.root = new Node('root', {
      as: 'root'
    });
    this.node = this.root;
    this.end = false;
    if (typeof this.stacker.link !== 'function') {
      Object.defineProperty(this.stacker, 'link', {
        get: function() {
          return Link.linker;
        }
      });
    }
  }

  Stack.prototype.stacker = function(label, fn) {
    return this.push(label, fn);
  };

  Stack.prototype.push = function(label, fn) {
    var from, klass;
    if (this.stack.length === 0) {
      this.emit('enter', null, this);
    }
    from = this.node;
    klass = this.pendingClass || this.label;
    if (typeof label === 'undefined') {
      return;
    }
    if (typeof label !== 'string') {
      if (this.hooks.set(from, label)) {
        return;
      }
    }
    this.node = new Node(label, {
      "function": fn,
      as: klass
    });
    Plugins.handle(this.node);
    if (fn && fn.fing.args.length > 0) {
      this.pendingClass = fn.fing.args[0].name;
    }
    if (label) {
      this.emit('tree:traverse', {
        as: 'Leafward',
        from: from,
        to: this.node
      });
      this.stack.push(this.node);
      this.classes.push(klass);
      try {
        if (fn) {
          injector.inject([this.stacker], fn);
        }
      } catch (error) {
        this.validate(null, error);
        this.emit('exit', error, this);
        return;
      }
      from = this.stack.pop();
      if (this.stack.length === 0) {
        this.node = this.root;
      } else {
        this.node = this.stack[this.stack.length - 1];
      }
      this.emit('tree:traverse', {
        as: 'Rootward',
        from: from,
        to: this.node
      });
      this.pendingClass = this.classes.pop();
      if (this.stack.length === 0) {
        return this.emit('exit', null, this);
      }
    }
  };

  Stack.prototype.validate = function(done, error) {
    if (this.activeNode.plugin && this.activeNode.plugin.validate) {
      return this.activeNode.plugin.validate(this.stack, error, function() {
        if (done) {
          return done();
        }
      });
    }
  };

  return Stack;

})(Emitter);
