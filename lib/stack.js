// Generated by CoffeeScript 1.4.0
var Injector, Node, Notifyier, Stack, notifier, stack;

require('fing');

Node = require('./node');

Notifyier = require('./notifier');

Injector = require('./injector');

stack = void 0;

notifier = void 0;

module.exports = Stack = (function() {

  function Stack(name) {
    this.name = name;
    this.stack = [];
    this.classes = [];
    this.root = new Node('root');
    this.node = this.root;
    this.end = false;
    notifier = Notifyier.create(this.name, {
      begin: {
        description: 'Enters root node'
      },
      push: {
        description: 'Enters a node'
      },
      pop: {
        description: 'Exits a node'
      },
      end: {
        description: 'Exits root node'
      },
      edge: {
        description: 'Edge traversal'
      }
    });
    stack = this;
  }

  Stack.prototype.stacker = function(label, callback) {
    return stack.push(arguments);
  };

  Stack.prototype.on = function(event, callback) {
    return notifier.on(event, callback);
  };

  Stack.prototype.once = function(event, callback) {
    return notifier.once(event, callback);
  };

  Stack.prototype.push = function(args) {
    var callback, from, klass, label;
    from = this.node;
    label = args[0];
    callback = args[1];
    klass = this.pendingClass || this.name;
    if (callback && callback.fing.args.length > 0) {
      this.pendingClass = callback.fing.args[0].name;
    }
    if (label) {
      this.node = new Node(label, {
        callback: callback,
        "class": klass
      });
      if (this.stack.length === 0) {
        notifier.emit('begin', '', this.node);
      }
      notifier.emit('push', '', this.node);
      notifier.emit('edge', '', {
        from: from,
        to: this.node
      });
      this.stack.push(this.node);
      this.classes.push(klass);
      try {
        if (callback) {
          Injector.inject([this.stacker], callback);
        }
      } catch (error) {
        if (error.name = 'AssertionError') {
          console.log(error.message.red);
          this.validate();
        } else {
          console.log(error);
          throw error;
        }
      }
      from = this.stack.pop();
      notifier.emit('pop', '', from);
      if (this.stack.length === 0) {
        this.node = this.root;
        notifier.emit('end', '', from);
      } else {
        this.node = this.stack[this.stack.length - 1];
      }
      notifier.emit('edge', '', {
        from: from,
        to: this.node
      });
      return this.pendingClass = this.classes.pop();
    }
  };

  Stack.prototype.validator = function(done) {
    return stack.validate(done);
  };

  Stack.prototype.validate = function(done) {
    var leafNode, node, testString, _i, _len, _ref;
    testString = '';
    leafNode = void 0;
    if (this.stack) {
      _ref = this.stack;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        testString += "" + node["class"] + " " + node.label.bold + " ";
        leafNode = node;
      }
      console.log(testString);
    }
    if (done) {
      return done();
    }
  };

  return Stack;

})();
