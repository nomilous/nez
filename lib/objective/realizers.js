// Generated by CoffeeScript 1.6.3
var EventEmitter, SpawnerFactory, defer;

defer = require('when').defer;

EventEmitter = require('events').EventEmitter;

SpawnerFactory = require('./spawner');

module.exports.createClass = function(classOpts, messageBus) {
  var api, emitter, fromfilename, realizers;
  realizers = {};
  fromfilename = {};
  emitter = new EventEmitter;
  messageBus.use(function(msg, next) {
    /* realizers collection middleware 1*/

    var match, responder, seq, uuid;
    if (!(uuid = msg.uuid)) {
      if (msg.event.match(/^phrase/)) {
        console.log('ignoring remote phrase tree activity:', msg.event);
      } else {
        console.log('EVENT:', msg.event, '\n', msg, '\n');
      }
      return next();
    }
    switch (msg.event) {
      case 'connect':
      case 'reconnect':
        realizers[uuid] || (realizers[uuid] = {});
        if (realizers[uuid].connected) {
          responder = msg.context.responder;
          return responder.event.bad('reject', {
            reason: "realizer:" + uuid + " already running @ " + realizers[uuid].pid + "." + realizers[uuid].hostname
          });
        }
        realizers[uuid].notice = (function() {
          try {
            return msg.context.responder;
          } catch (_error) {}
        })();
        realizers[uuid].connected = true;
        realizers[uuid].pid = msg.pid;
        realizers[uuid].hostname = msg.hostname;
        emitter.emit(msg.event, realizers[uuid]);
        realizers[uuid].notice.use(function(msg, next) {
          if (msg.event === 'disconnect') {
            realizers[uuid].connected = false;
            emitter.emit(msg.event, realizers[uuid]);
          }
          return next();
        });
        if (msg.event === 'connect' && classOpts.autoload) {
          return msg.context.responder.event('load').then(function() {
            return next();
          }, function() {
            return next();
          });
        }
        return next();
      case 'error':
        emitter.emit(msg.event, realizers[uuid], msg);
        return next();
      default:
        if (match = msg.event.match(/^ready::(\d)/)) {
          seq = parseInt(match[1]);
          emitter.emit('ready', realizers[uuid], seq);
          if (seq === 1 && classOpts.autorun) {
            return msg.context.responder.event('run', {
              uuid: uuid
            }).then(function() {
              return next();
            }, function() {
              return next();
            });
          }
        }
        return next();
    }
  });
  api = emitter;
  api.autospawn = false;
  api.spawner = SpawnerFactory.createClass(classOpts, messageBus);
  api.get = function(opts) {
    var getting,
      _this = this;
    if (opts == null) {
      opts = {};
    }
    getting = defer();
    process.nextTick(function() {
      var doSpawn, realizer;
      if (opts.uuid != null) {
        if (realizers[opts.uuid] != null) {
          return getting.resolve(realizers[opts.uuid]);
        }
        return getting.reject(new Error("Missing realizer uuid:" + opts.uuid));
      }
      if (opts.filename != null) {
        realizer = fromfilename[opts.filename];
        doSpawn = api.autospawn && (realizer.token.localPID == null);
        if (!doSpawn) {
          return getting.resolve(realizer);
        }
        return api.spawner.spawn(realizer.token).then(function(token) {
          return getting.resolve(realizers[token.uuid]);
        }, function(error) {
          return getting.reject(error);
        });
      }
    });
    return getting.promise;
  };
  api.update = function(tokens) {
    var updating,
      _this = this;
    updating = defer();
    process.nextTick(function() {
      var filename, path, token, uuid;
      for (path in tokens) {
        token = tokens[path];
        uuid = token.uuid;
        if (token.type !== 'tree') {
          continue;
        }
        realizers[uuid] || (realizers[uuid] = {});
        realizers[uuid].token = token;
        realizers[uuid].connected = false;
        if (token.source == null) {
          continue;
        }
        switch (token.source.type) {
          case 'file':
            filename = token.source.filename;
            fromfilename[filename] = realizers[uuid];
        }
      }
      return updating.resolve();
    });
    return updating.promise;
  };
  return api;
};
