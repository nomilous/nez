// Generated by CoffeeScript 1.6.3
var ChildProcess, defer, path;

defer = require('when').defer;

ChildProcess = require('child_process');

path = require('path');

module.exports.createClass = function(opts, messageBus) {
  var connected, waiting;
  waiting = {};
  connected = {};
  messageBus.use(function(msg, next) {
    var promise, token, _ref;
    if (msg.context.title === 'realizer::connect') {
      if (waiting[msg.pid] != null) {
        _ref = waiting[msg.pid], promise = _ref.promise, token = _ref.token;
        if (token.uuid !== msg.uuid) {
          return next();
        }
        console.log({
          CONNECT: token.uuid,
          PID: msg.pid
        });
        connected[msg.pid] = {
          token: token
        };
        token.localPID = msg.pid;
        promise.resolve(token);
        delete waiting[msg.pid];
      } else {
        if (opts.autospawn) {
          console.log("autospawn ignored realizer at pid:" + msg.pid);
        }
      }
    }
    return next();
  });
  return {
    spawn: function(token) {
      var spawning;
      if (token == null) {
        token = {};
      }
      spawning = defer();
      process.nextTick(function() {
        var args, child, runner;
        if (token.localPID != null) {
          return spawning.reject(new Error("Already running realizer at pid: " + token.localPID));
        }
        if (!((token.source != null) && token.source.type === 'file' && (token.source.filename != null))) {
          return spawning.reject(new Error("Realizer can only spawn local source"));
        }
        runner = path.normalize(__dirname + '/../../bin/realize');
        args = ['-c', '-p', opts.listening.port];
        if (opts.listening.transport !== 'https') {
          args.push('-X');
        }
        args.push(token.source.filename);
        try {
          process.env['SECRET'] = opts.listen.secret;
        } catch (_error) {}
        child = ChildProcess.spawn(runner, args);
        console.log({
          SPAWN: token.uuid,
          PID: child.pid
        });
        waiting[child.pid] = {
          promise: spawning,
          token: token
        };
        child.stderr.on('data', function(data) {});
        child.stdout.on('data', function(data) {
          return console.log('------->', data.toString());
        });
        return child.on('exit', function(code, signal) {
          var promise, _ref;
          if (waiting[child.pid] != null) {
            _ref = waiting[child.pid], promise = _ref.promise, token = _ref.token;
            promise.reject(new Error("Realizer exited with code:" + code + ", signal:" + signal));
            return;
          }
          if (connected[child.pid] != null) {
            token = connected[child.pid].token;
            delete token.localPID;
            delete connected[child.pid];
            console.log({
              DISCONNECT: token.uuid,
              PID: child.pid,
              code: code,
              signal: signal
            });
          }
        });
      });
      return spawning.promise;
    }
  };
};
