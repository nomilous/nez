// Generated by CoffeeScript 1.6.3
var Notice, defer, factory, wait;

Notice = require('notice');

wait = require('also').schedule.wait;

defer = require('when').defer;

factory = function(context, notice, callback) {
  var checksum, children, collection, pids, spawnedAt, startedAt, startedLag;
  collection = {};
  startedAt = {};
  children = {};
  checksum = {};
  spawnedAt = {};
  startedLag = {};
  pids = {};
  return Notice.listen('realizers', context, function(error, Realizers) {
    var api;
    Realizers.use(function(msg, next) {
      var id, properties, reply;
      switch (msg.context.title) {
        case 'realizer::register':
          properties = msg.properties;
          id = properties.id || properties.script;
          reply = msg.reply;
          collection[id] = reply;
          startedAt[id] = Date.now();
          if (spawnedAt[id] != null) {
            startedLag[id] = startedAt[id] - spawnedAt[id];
          }
          delete spawnedAt[id];
      }
      return next();
    });
    if (error != null) {
      return callback(error);
    }
    return callback(null, api = {
      task: function(title, ref) {
        var taskDeferral;
        taskDeferral = defer();
        api.get(ref, function(error, realizer) {
          if (error != null) {
            taskDeferral.reject(error);
            return notice.event.bad('missing or broken realizer', {
              description: ref.id,
              error: error
            });
          }
          return realizer.task(title, ref).then(taskDeferral.resolve, taskDeferral.reject, taskDeferral.notify);
        });
        return taskDeferral.promise;
      },
      get: function(ref, callback) {
        var child, pid;
        if (!((ref != null) && (ref.id != null))) {
          throw new Error('realizers.get(ref, callback) requires ref.id as the realizer id');
        }
        if (collection[ref.id] != null) {
          if (!((children[ref.id] != null) && checksum[ref.id] !== context.tools.checksum.file(ref.id))) {
            return callback(null, collection[ref.id]);
          }
          child = children[ref.id];
          pid = child.pid;
          child.kill();
          delete collection[ref.id];
          delete children[ref.id];
          delete spawnedAt[ref.id];
          delete pids[pid];
        }
        if (ref.script == null) {
          return callback(new Error('missing realizer'));
        }
        if (ref.script.match(/\.(lit)*coffee$/) == null) {
          return callback(new Error('nez supports only coffee-script realizers'));
        }
        process.env['UPLINK_transport'] = context.listening.transport;
        process.env['UPLINK_address'] = context.listening.address;
        process.env['UPLINK_port'] = context.listening.port;
        if (spawnedAt[ref.script] != null) {
          return notice.info('already waiting for realizer', {
            description: "pid:" + children[ref.script].pid + ", script:" + ref.script
          });
        }
        return context.tools.spawn(notice, {
          "arguments": [ref.script],
          exit: function(pid) {
            var id;
            id = pids[pid];
            delete collection[id];
            delete children[id];
            delete spawnedAt[id];
            return delete pids[pid];
          }
        }, function(error, child) {
          pids[child.pid] = ref.script;
          children[ref.script] = child;
          if (error == null) {
            spawnedAt[ref.script] = Date.now();
            checksum[ref.script] = context.tools.checksum.file(ref.script);
            wait({
              until: function() {
                return (collection[ref.script] != null) || (pids[child.pid] == null);
              }
            }, function() {
              if (collection[ref.script] == null) {
                return callback(new Error('realizer exited before connecting'));
              }
              return callback(null, collection[ref.script]);
            }).apply(null);
          }
          return child.stdout.on('data', function(data) {
            var line, lines, _i, _len, _results;
            lines = data.toString().split('\n');
            _results = [];
            for (_i = 0, _len = lines.length; _i < _len; _i++) {
              line = lines[_i];
              _results.push(console.log('---------->', line));
            }
            return _results;
          });
        });
      }
    });
  });
};

module.exports = factory;
