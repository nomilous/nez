// Generated by CoffeeScript 1.6.3
var Notice, factory, wait;

Notice = require('notice');

wait = require('also').schedule.wait;

factory = function(context, notice, callback) {
  var collection, pids;
  collection = {};
  pids = {};
  return Notice.listen('realizers', context, function(error, Realizers) {
    var integrations;
    Realizers.use(function(msg, next) {
      var reply, script;
      switch (msg.context.title) {
        case 'realizer::start':
          script = msg.payload.properties.script;
          reply = msg.reply;
          collection[script] = reply;
      }
      return next();
    });
    if (error != null) {
      return callback(error);
    }
    return callback(null, integrations = {
      task: function(title, ref) {
        return integrations.get(ref, function(err, realizer) {
          return realizer.task(title, ref);
        });
      },
      get: function(ref, callback) {
        if (!((ref != null) && (ref.id != null))) {
          throw new Error('realizers.get(ref, callback) requires ref.id as the realizer id');
        }
        if (collection[ref.id] != null) {
          return callback(null, collection[ref.script]);
        }
        if (ref.script == null) {
          return callback(new Error('missing realizer'));
        }
        if (ref.script.match(/\.(lit)*coffee$/) == null) {
          return callback(new Error('nez supports only coffee-script realizers'));
        }
        process.env['UPLINK_transport'] = context.listening.transport;
        process.env['UPLINK_address'] = context.listening.address;
        process.env['UPLINK_port'] = context.listening.port;
        return context.tools.spawn(notice, {
          "arguments": [ref.script],
          exit: function(pid) {
            var id;
            console.log('exit', pid, pids[pid], arguments);
            id = pids[pid];
            delete collection[id];
            return delete pids[pid];
          }
        }, function(error, child) {
          pids[child.pid] = ref.script;
          if (error == null) {
            wait({
              until: function() {
                return (collection[ref.script] != null) || (pids[child.pid] == null);
              }
            }, function() {
              return callback(null, collection[ref.script]);
            }).apply(null);
          }
          return child.stdout.on('data', function(data) {
            var line, lines, _i, _len, _results;
            lines = data.toString().split('\n');
            _results = [];
            for (_i = 0, _len = lines.length; _i < _len; _i++) {
              line = lines[_i];
              _results.push(console.log('---------->', line));
            }
            return _results;
          });
        });
      }
    });
  });
};

module.exports = factory;
