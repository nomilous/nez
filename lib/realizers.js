// Generated by CoffeeScript 1.6.3
var Notice, defer, factory, tasks, wait;

Notice = require('notice');

wait = require('also').schedule.wait;

defer = require('when').defer;

tasks = require('does').tasks;

factory = function(context, notice, callback) {
  var checksum, children, collection, pids, spawnedAt, startedAt, startedLag;
  collection = {};
  startedAt = {};
  children = {};
  checksum = {};
  spawnedAt = {};
  startedLag = {};
  pids = {};
  return Notice.listen('realizers', context, function(error, Realizer) {
    var api;
    Realizer.use(function(msg, next) {
      var opts, task, uuid;
      switch (msg.context.title) {
        case 'realizer::register':
          opts = msg.properties;
          uuid = opts.uuid;
          opts.notice = msg.reply;
          tasks.task(opts, function(error, task) {
            collection[uuid] = task;
            startedAt[uuid] = Date.now();
            if (spawnedAt[uuid] != null) {
              startedLag[uuid] = startedAt[uuid] - spawnedAt[uuid];
            }
            return delete spawnedAt[uuid];
          });
          return next();
        default:
          if ((msg.uuid != null) && (collection[msg.uuid] != null)) {
            task = collection[msg.uuid];
            return task.message(msg, next);
          } else {
            return next();
          }
      }
    });
    if (error != null) {
      return callback(error);
    }
    return callback(null, api = {
      start: function(opts) {
        var running;
        running = defer();
        api.get(opts, function(error, realizer) {
          if (error != null) {
            running.reject(error);
            return notice.event.bad('missing or broken realizer', {
              realizer: opts.uuid,
              script: opts.script,
              error: error
            });
          }
          return realizer.start(opts).then(running.resolve, running.reject, running.notify);
        });
        return running.promise;
      },
      get: function(ref, callback) {
        var child, pid, task;
        if (!((ref != null) && (ref.uuid != null))) {
          throw new Error('realizers.get(ref, callback) requires ref.uuid as the realizer uuid');
        }
        if (collection[ref.uuid] != null) {
          if (!((children[ref.uuid] != null) && checksum[ref.uuid] !== context.tools.checksum.file(ref.script))) {
            return callback(null, collection[ref.uuid]);
          }
          task = collection[ref.uuid];
          child = children[ref.uuid];
          pid = child.pid;
          task.terminate();
          child.kill();
          delete collection[ref.uuid];
          delete children[ref.uuid];
          delete spawnedAt[ref.uuid];
          delete pids[pid];
        }
        if (ref.script == null) {
          return callback(new Error('missing realizer'));
        }
        if (ref.script.match(/\.(lit)*coffee$/) == null) {
          return callback(new Error('nez supports only coffee-script realizers'));
        }
        process.env['UPLINK_transport'] = context.listening.transport;
        process.env['UPLINK_address'] = context.listening.address;
        process.env['UPLINK_port'] = context.listening.port;
        if (spawnedAt[ref.uuid] != null) {
          return notice.info('already waiting for realizer', {
            description: "pid:" + children[ref.uuid].pid + ", script:" + ref.script
          });
        }
        return context.tools.spawn(notice, {
          "arguments": [ref.script],
          exit: function(pid) {
            var uuid;
            uuid = pids[pid];
            delete collection[uuid];
            delete children[uuid];
            delete spawnedAt[uuid];
            return delete pids[pid];
          }
        }, function(error, child) {
          pids[child.pid] = ref.script;
          children[ref.uuid] = child;
          if (error == null) {
            spawnedAt[ref.uuid] = Date.now();
            checksum[ref.uuid] = context.tools.checksum.file(ref.script);
            wait({
              until: function() {
                return (collection[ref.uuid] != null) || (pids[child.pid] == null);
              }
            }, function() {
              if (collection[ref.uuid] == null) {
                return callback(new Error('realizer exited before connecting'));
              }
              return callback(null, collection[ref.uuid]);
            }).apply(null);
          }
          return child.stdout.on('data', function(data) {
            var line, lines, _i, _len, _results;
            lines = data.toString().split('\n');
            _results = [];
            for (_i = 0, _len = lines.length; _i < _len; _i++) {
              line = lines[_i];
              _results.push(console.log('---------->', line));
            }
            return _results;
          });
        });
      }
    });
  });
};

module.exports = factory;
