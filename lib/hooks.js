// Generated by CoffeeScript 1.4.0
var Hooks, hooks;

if (typeof fing === 'undefined') {
  require('fing');
}

Hooks = (function() {

  function Hooks(subscribe) {
    subscribe('edge', this.handle);
  }

  Hooks.prototype.set = function(node, config) {
    var key, wasHook;
    wasHook = false;
    for (key in config) {
      if (key === 'beforeEach' || key === 'afterEach') {
        node.hooks[key] = config[key];
        wasHook = true;
      }
      if (key === 'beforeAll' || key === 'afterAll') {
        node.hooks[key] = config[key];
        wasHook = true;
      }
    }
    return wasHook;
  };

  Hooks.prototype.handle = function(placeholder, nodes) {
    var allHook, ancestor, ancestors, eachHook, node, _i, _len;
    switch (nodes["class"]) {
      case 'Tree.Leafward':
        node = nodes.from;
        eachHook = 'beforeEach';
        allHook = 'beforeAll';
        break;
      case 'Tree.Rootward':
        node = nodes.to;
        eachHook = 'afterEach';
        allHook = 'afterAll';
    }
    ancestors = node.stack.ancestorsOf(node);
    for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
      ancestor = ancestors[_i];
      if (typeof ancestor.hooks[eachHook] !== 'undefined') {
        ancestor.hooks[eachHook]();
      }
    }
    if (typeof node.hooks[eachHook] !== 'undefined') {
      node.hooks[eachHook]();
    }
    if (typeof node.hooks[allHook] !== 'undefined') {
      node.hooks[allHook]();
      return delete node.hooks[allHook];
    }
  };

  return Hooks;

})();

hooks = {};

module.exports = {
  getFor: function(stack) {
    var _name;
    return hooks[_name = stack.fing.ref] || (hooks[_name] = new Hooks(stack.on));
  }
};
