// Generated by CoffeeScript 1.4.0
var ActiveNode, Defaults, Http, Injector, Plex, PluginLoader, Runtime, Stack;

Defaults = require('./defaults');

PluginLoader = require('./plugin_loader');

Injector = require('nezcore').injector;

Runtime = require('nezcore').runtime;

Stack = require('./stack');

Http = require('http');

Plex = require('plex');

module.exports = ActiveNode = (function() {

  function ActiveNode(label, config, injectable) {
    var tags,
      _this = this;
    this.label = label;
    this.config = config != null ? config : {};
    this.injectable = injectable != null ? injectable : function() {};
    this.config._runtime = new Runtime();
    this.logger = this.config._runtime.logger;
    this.nodeID = process.env.NODE_ID;
    tags = process.env.NODE_TAGS || '';
    this.tags = tags.split(' ');
    this.logger.info('active config lookup', {
      as: this.config.as || process.env.NODE_AS,
      nodeID: this.nodeID,
      tags: this.tags
    });
    this.outerValidate();
    this.config.as(this.nodeID, this.tags, function(activeConfig) {
      _this.logger.verbose('received active config', activeConfig);
      _this.innerValidate(activeConfig);
      return _this.start(activeConfig);
    });
  }

  ActiveNode.prototype.start = function(activeConfig) {
    var match, server, service, services, stacker, type, validate, _i, _len, _ref,
      _this = this;
    if (typeof activeConfig._objective !== 'undefined') {
      type = '_objective';
    } else if (typeof activeConfig._realizer !== 'undefined') {
      type = '_realizer';
    } else {
      throw new Error("ActiveNode should be an Objective or a Realizer");
    }
    this.logger.verbose('starting', {
      label: this.label,
      category: this.config.category
    });
    if (type === '_objective') {
      if (typeof activeConfig[type].plex !== 'undefined') {
        server = Http.createServer();
        server.listen(20202, 'localhost', function() {
          var iface, port;
          iface = server.address().address;
          port = server.address().port;
          return _this.logger.info("listening for realizers @ " + iface + ":" + port);
        });
        activeConfig[type].plex.listen.server = server;
      }
    }
    this.stack = new Stack(this);
    this.config._class = activeConfig[type]["class"];
    this.plugin = PluginLoader.load(this.stack, this.config);
    if (typeof activeConfig[type].plex !== 'undefined') {
      activeConfig[type].plex.protocol = this.plugin.bind;
      this.plex = Plex.start(activeConfig[type].plex);
    }
    services = [];
    stacker = function() {
      return _this.stack.stacker.apply(_this.stack, arguments);
    };
    stacker.link = this.stack.stacker.link;
    services.push(stacker);
    if (type === '_realizer') {
      validate = function() {
        return _this.stack.validate.apply(_this.stack, arguments);
      };
      services.push(validate);
    }
    if (typeof this.config["with"] !== 'undefined') {
      _ref = this.config["with"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        service = _ref[_i];
        if (typeof service !== 'string') {
          services.push(service);
          continue;
        }
        try {
          if (match = service.match(/^(.*):(.*)$/)) {
            services.push(Injector.support.findModule({
              module: match[1]
            })[match[2]]);
          } else {
            services.push(Injector.support.findModule({
              module: service
            }));
          }
        } catch (error) {
          this.logger.error("error loading service '" + service + "'");
          services.push(void 0);
        }
      }
    }
    if (typeof this.injectable === 'function') {
      Injector.inject(services, this.injectable);
      if (type === '_realizer') {
        return this.plex.stop();
      }
    }
  };

  ActiveNode.prototype.innerValidate = function(config) {};

  ActiveNode.prototype.outerValidate = function() {
    var match;
    if (typeof this.label !== 'string') {
      throw new Error("ActiveNode requires 'label' string as arg1");
    }
    if (typeof this.config.as === 'undefined') {
      this.config.as = process.env.NODE_AS;
    }
    if (typeof this.config.as === 'string') {
      if (typeof Defaults[this.config.as] !== 'undefined') {
        return this.config.as = Defaults[this.config.as];
      } else {
        try {
          if (match = this.config.as.match(/^(.*):(.*)$/)) {
            return this.config.as = require(match[1])[match[2]];
          } else {
            return this.config.as = require(this.config.as);
          }
        } catch (error) {
          this.logger.error("active config lookup failed for '" + this.config.as + "'");
          throw error;
        }
      }
    }
  };

  return ActiveNode;

})();
