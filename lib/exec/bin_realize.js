// Generated by CoffeeScript 1.6.3
var Realize, defer, fs, hostname, marshalArgs, notice, phrase, pipeline, program, runRealizer, sequence, startNotifier, withError;

program = require('commander');

fs = require('fs');

phrase = require('phrase');

defer = require('when').defer;

pipeline = require('when/pipeline');

sequence = require('when/sequence');

notice = require('notice');

hostname = require('os').hostname;

Realize = require('../realization/realize');

program.version(JSON.parse(fs.readFileSync(__dirname + '/../../package.json', 'utf8')).version);

program.usage('[options] [realizer]');

program.option('-c, --connect', 'Establish connection to objective', false);

program.option('-p, --port  <num>      ', 'Objective port', 10001);

program.option('-X, --no-https         ', 'Connect insecurely', false);

program.parse(process.argv);

pipeline([
  function() {
    return marshalArgs(program);
  }, function(params) {
    return Realize.loadRealizer(params);
  }, function(realizer) {
    return startNotifier(realizer);
  }, function(controls) {
    return runRealizer(controls);
  }
]).then(function(resolve) {}, function(error) {
  console.log({
    ERROR: error
  });
  process.stderr.write(error.toString());
  return process.exit(error.errno || 100);
}, function(notify) {});

runRealizer = function(_arg) {
  var init, opts, phraseRecursor, realizerFn, running, uplink;
  uplink = _arg.uplink, opts = _arg.opts, realizerFn = _arg.realizerFn;
  running = defer();
  opts.notice = uplink;
  phraseRecursor = phrase.createRoot(opts, function(token) {});
  init = function() {
    return phraseRecursor('realizer', realizerFn);
  };
  uplink.use(function(msg, next) {
    var error, key;
    switch (msg.context.direction) {
      case 'out':
        switch (msg.event) {
          case 'connect':
          case 'reconnect':
          case 'ready':
          case 'error':
            msg.uuid = opts.uuid;
            msg.pid = process.pid;
            msg.hostname = hostname();
            console.log({
              SENDING: msg.context
            }, msg);
            return next();
          default:
            console.log({
              SENDING: msg.context
            }, msg);
            return next();
        }
        break;
      case 'in':
        console.log({
          RECEIVING: msg.context
        }, msg);
        switch (msg.event) {
          case 'reject':
            error = new Error(msg.event);
            error.errno = 101;
            for (key in msg) {
              error[key] = msg[key];
            }
            return running.reject(error);
          case 'init':
            return init().then(function(result) {
              return uplink.event.good('ready');
            }, function(error) {
              var payload;
              payload = {
                error: error
              };
              try {
                payload.stack = error.stack;
              } catch (_error) {}
              return uplink.event.bad('error', payload);
            });
          default:
            return next();
        }
    }
  });
  return running.promise;
};

startNotifier = function(_arg) {
  var opts, realizerFn, start;
  opts = _arg.opts, realizerFn = _arg.realizerFn;
  start = defer();
  process.nextTick(function() {
    var key, origin;
    if (opts.connect == null) {
      return start.resolve({
        uplink: notice.create("" + opts.uuid),
        opts: opts,
        realizerFn: realizerFn
      });
    }
    origin = {};
    for (key in opts) {
      if (key === 'connect') {
        continue;
      }
      origin[key] = opts[key];
    }
    opts.origin = origin;
    return notice.connect("" + opts.uuid, opts, function(error, uplink) {
      if (error != null) {
        return start.reject(error);
      }
      return start.resolve({
        uplink: uplink,
        opts: opts,
        realizerFn: realizerFn
      });
    });
  });
  return start.promise;
};

marshalArgs = function(program) {
  var marshal;
  marshal = defer();
  process.nextTick(function() {
    return marshal.resolve({
      filename: program.args[0],
      connect: program.connect,
      https: program.https,
      port: program.port
    });
  });
  return marshal.promise;
};

withError = function(errno, code, message) {
  var error;
  error = new Error(message);
  error.errno = errno;
  error.code = code;
  return error;
};
