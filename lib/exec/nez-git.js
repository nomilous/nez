// Generated by CoffeeScript 1.4.0
var colors, context, fs, program;

program = require('commander');

colors = require('colors');

fs = require('fs');

context = {
  root: function() {
    return program.root || '.';
  },
  huh: function() {
    return console.log("\nQuick Huh?\n----------\n\nFor managing an n-tier nested git repository as a replicatable entity.\n\n");
  },
  huhh: function() {
    return console.log("\n\nLong Huh?\n---------\n\nImagine working on portions of a node based system called AbraCadabra. And \nthis system is comprised of a multitude of many smaller components each \ndistributed as singlarly purposed npm modules.\n\nYou're currently focussed on the completion ofthe next release of the Cadabra \nfeature which relies in having not yet released versions of several other \nsmaller components appropriately installed as ./node_modules for their ease \nof distribution and open saucy-ness.\n\nBut you cannot install them with the npm install tool because they are not yet \nreleased. And additionally you are also want to occasionally commit the odd \nminor change to some of those sub modules to enable the new features being \nintegrated into AbraCadabra.\n\nSo you have installed git clones of each of those submodules into ./node_modules\nand are having a fair amount of difficulty keeping track of all the repositories \nthat require sync actions.\n\n\n\nThe command...\ncd /home/me/git/abra_cadabra && nez-git init\n\n...will build a .git_root file that contains a reference to each git repo clone \nnested within the specified root.\n\n\n\nIt contains records per repo as follows...\nPATH,ORIGIN,BRANCH,REF\n\n...where PATH is the nested location of the root of each repo and ORIGIN is the \norigin git repo and BRANCH and REF specify the current git/ref (version) that \neach repo should be at at in order for the whole to function as a whole.\n\n\n\nThen the command...\nnez-git status\n\n...will present the unified status across all nested repositories. \n\n\n\nNow imagine you're not the only person working on the pending release of \nAbraCadabra and you've just commited a change into one of the sub modules \nin a nested git repo effectively creating a situation where another team \nmembers pull of your just pushed root module will break their environment \nunless they also pull the nested submodule repo. \n\nProblem is that the submodule repo is .gitignored so git itself has no idea \nof that nested dependancy change.\n\n\n\nThe command...\nnez-git push \n\n\n...will push all repos that have commits pending and then update that .git_root \nfile with the new BRANCH,REF where changed. And push that too.\n\n\n\nWhich then enables the command...\nnez-git pull\n\n...to first collect the new .git_root files and then to pull all changes across \nthe entire tree.\n");
  },
  init: function() {
    var branch, controlData, controlFile, exec, origin, path, ref, repo, _i, _len, _ref;
    controlFile = "" + (context.root()) + "/.git_root";
    controlData = '';
    exec = require('exec-sync');
    _ref = exec("find " + (context.root()) + " | grep -e \/.git\/ | grep -oe ^.*\/.git | sort | uniq").split('\n');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      repo = _ref[_i];
      path = repo.match(/(.*)\/.git/)[1];
      origin = exec("git --git-dir=" + repo + " config --get remote.origin.url");
      branch = exec("cat " + repo + "/HEAD").match(/ref: (.*)$/)[1];
      ref = exec("cat " + repo + "/" + branch);
      controlData += "" + path + "," + origin + "," + branch + "," + ref + "\n";
    }
    return fs.writeFileSync(controlFile, controlData);
  },
  status: function() {
    var branch, exec, line, origin, parts, path, ref, status, _i, _len, _ref, _results;
    _ref = fs.readFileSync("" + (context.root()) + "/.git_root").toString().split('\n');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (!(line.length > 0)) {
        continue;
      }
      parts = line.match(/(.*),(.*),(.*),(.*)/);
      path = parts[1];
      origin = parts[2];
      branch = parts[3];
      ref = parts[4];
      exec = require('exec-sync');
      try {
        fs.lstatSync(path);
      } catch (error) {
        console.log(("\nMISSING @ repo:" + path).red);
        console.log("run: nez-git --root " + (context.root()) + " pull # (from the git_root)");
        continue;
      }
      status = exec("git --git-dir=" + path + "/.git --work-tree=" + path + "/ status");
      console.log(("\nSTATUS @ repo:" + path).green);
      _results.push(console.log(status));
    }
    return _results;
  },
  pull: function() {
    var branch, exec, line, origin, parts, path, ref, _i, _len, _ref, _results;
    _ref = fs.readFileSync("" + (context.root()) + "/.git_root").toString().split('\n');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      if (!(line.length > 0)) {
        continue;
      }
      parts = line.match(/(.*),(.*),(.*),(.*)/);
      path = parts[1];
      origin = parts[2];
      branch = parts[3];
      ref = parts[4];
      console.log(("SYNC (pull) @ " + path).green);
      exec = require('exec-sync');
      try {
        fs.lstatSync("" + (context.root()) + "/" + path);
      } catch (error) {
        if (error.code === 'ENOENT') {
          context.shellSync("mkdir -p " + (context.root()) + "/" + path);
        }
      }
      try {
        _results.push(fs.lstatSync("" + (context.root()) + "/" + path + "/.git"));
      } catch (error) {
        if (error.code === 'ENOENT') {
          _results.push(context.spawnSync('git', ['clone', origin, "" + (context.root()) + "/" + path]));
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  },
  push: function() {},
  shellSync: function(command) {
    var exec;
    console.log('(run)'.bold, command);
    exec = require('exec-sync');
    return exec(command);
  },
  spawnSync: function(bin, opts) {
    var series, spawn;
    series = require('async').series;
    spawn = require('child_process').spawn;
    return series([
      function() {
        var child;
        console.log('(run)'.bold, bin, opts.join(' '));
        child = spawn(bin, opts);
        child.stdout.pipe(process.stdout);
        return child.stderr.pipe(process.stderr);
      }
    ]);
  }
};

program.option('-r, --root [root]', 'Specify the root repo. Default ./');

program.command('huh?').description('Explains briefly the purpose of this tool.').action(function() {
  return context.huh();
});

program.command('HUH?').description('Explains more fully the purpose of this tool.').action(function() {
  return context.huhh();
});

program.command('init').description('Assemble the initial .git_root control file into [root]').action(function() {
  return context.init();
});

program.command('status').description('Git status across all nested git repos').action(function() {
  return context.status();
});

program.command('pull').description('Git pull across all nested git repos not up-to-date with .git_root').action(function() {
  return context.pull();
});

program.command('push').description('Git push across all nested git repos pending commits and update .git_root').action(function() {
  return context.push();
});

program.parse(process.argv);
